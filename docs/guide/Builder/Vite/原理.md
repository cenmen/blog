# Vite 原理

- 基于浏览器支持 ES 模块
- **当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建整个应用，然后才能提供服务。**
- 通过项目首页 index.html 开始对代码进行引用
- 因浏览器只认识 html 、css、js 文件以及引用路径为 '/'，'./'，相对路径
- 将对依赖包的引用路径修改为对本地 node_modules 打包后的文件引用路径
- 针对部分文件需进行编译，例如解析 .vue 文件

## 依赖预构建

Vite 通过在一开始将应用中的模块区分为 **依赖** 和 **源码** 两类，改进了开发服务器启动时间。

- **依赖** 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。

Vite 将会使用 **esbuild 预构建依赖**。将其他规范的代码转换成 esmodule 规范, 然后放到当前目录下的 node_modules/.vite/deps, 同时对 esmodule 规范的各个模块进行统一集成。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。

- **源码** 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。但并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。

Vite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。

Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。

解决了 3 个问题:

1. 不同的第三方依赖包会有不同的模块化格式（例如 ESM 或者 CommonJS）
2. 对路径的处理上可以直接使用 .vite/deps, 方便路径重写
3. 叫做网络多包传输的性能问题(也是原生 esmodule 规范不敢支持 node_modules 的原因之一), 有了依赖预构建以后无论他有多少的额外 export 和 import, vite 都会尽可能的将他们进行集成最后只生成一个或者几个模块

## Vite 的启动步骤

1. 读取相关配置
2. 进行依赖预构建

- 将其他规范的代码转换成 esmodule 规范
- 对依赖模块进行统一集成
- 存放修改后的模块依赖到本地的 node_modules/.vite/deps
- 转换代码中依赖模块的路径
- 启动开发服务器
- 根据浏览器请求逐步递归模块响应到浏览器上

## Vite 与 Webpack 的区别及优缺点

- webpack 支持多种模块化, 初次编译需要将所有模块进行处理，需要更长的时间才能启动开发服务器
- webpack 更多的关注兼容性, 而 vite 侧重关注浏览器端的开发体验
- webpack 的编译原理是通过 AST 抽象语法分析的工具 分析出你写的这个 js 文件有哪些导入和导出操作

## Vite 特点总结

1. 使用 esbuild 进行依赖预构建
2. 利用浏览器的 ES 模块和请求缓存（强缓存 & 协商缓存）
3. 利用浏览器请求按需提供源码

## FAQ

1. 浏览器如何识别开发服务器的 .vue 等文件
2. 代码修改是如何反应到浏览器上
3. 如何解决 css 模块化问题  
   为 css 文件添加后缀 xx.module.css ，vite 修改 css 中定义的类名添加 hash 值，防止类名被覆盖，并且将 css 内容修改为 js 代码响应给浏览器执行，在 head 标签插入 style 标签
4. 为何不用 ESBuild 打包  
   虽然 esbuild 快得惊人，并且已经是一个在构建库方面比较出色的工具，但一些针对构建应用的重要功能仍然还在持续开发中 —— 特别是代码分割和 CSS 处理方面。就目前来说，Rollup 在应用打包方面更加成熟和灵活。

## 相关链接

- [为什么选 Vite](https://cn.vitejs.dev/guide/why.html)
